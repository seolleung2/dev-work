# React에서의 복잡한 상태 관리와 변경 버그

## 그라데이션 생성기 버그 해결

- `setColors` 호출이 작동하지 않는 문제 발생
- React 상태에서 객체나 배열을 직접 수정하면 버그 발생
  - React는 참조 동등성을 사용하여 상태 변경 감지
  - 배열 변경은 새 배열을 생성하지 않아 React가 재렌더링하지 않음
- 해결책: 스프레드 구문(`...`)을 사용하여 새 배열 생성

## 주의사항

- 변경과 객체 참조는 고급 주제
- 초보자에게는 어려울 수 있음
- Dave Ceddia의 "JavaScript에서의 참조에 대한 시각적 가이드" 참고 권장
- Immer 도구를 사용하면 이러한 문제 해결 가능

## React 상태 변경 금지

올바른 순서:

1. 새 배열 생성
2. 새 배열 수정
3. 새 배열을 상태에 설정

### 올바른 방법:

```jsx
<input
  id={colorId}
  type="color"
  value={color}
  onChange={(event) => {
    const copiedColors = [...colors];
    copiedColors[index] = event.target.value;
    setColors(copiedColors);
  }}
/>
```

### 잘못된 방법:

```jsx
<input
  onChange={(event) => {
    colors[index] = event.target.value; // 배열 직접 변경
    setColors([...colors]); // 새 복사본 생성 및 상태 설정
  }}
/>
```

### 차이점 설명:

1. **상태 변경 순서**:

   - 올바른 방법: 먼저 새 배열을 생성하고, 그 후에 수정합니다.
   - 잘못된 방법: 기존 상태 배열을 직접 수정한 후, 복사본을 만듭니다.

2. **React 상태 불변성 원칙**:

   - 올바른 방법: React 상태의 불변성을 유지합니다.
   - 잘못된 방법: React 상태를 직접 수정하여 불변성 원칙을 위반합니다.

3. **예측 가능성**:

   - 올바른 방법: 항상 예측 가능한 결과를 제공합니다.
   - 잘못된 방법: 때때로 작동하는 것처럼 보이지만, 예측할 수 없는 버그를 유발할 수 있습니다.

4. **React의 상태 감지**:
   - 올바른 방법: React가 항상 새로운 상태를 감지하고 적절히 반응합니다.
   - 잘못된 방법: React가 상태 변경을 감지하지 못할 수 있어, 재렌더링이 일어나지 않을 수 있습니다.

## 성능에 대한 고려사항

- 새 배열 생성이 비효율적으로 보일 수 있으나, 실제로는 매우 빠름
- 테스트 결과:
  - 고성능 및 저성능 장치 모두에서 0ms에 가까운 시간 소요
  - 1000번 반복 시에도 약 2ms 소요 (저사양 장치 기준)
- 배열 크기에 따라 다를 수 있으나, 일반적인 프론트엔드 작업에서는 문제되지 않음

## 결론

- 현대 JS 엔진은 매우 빠름
- 프론트엔드 성능 최적화 시 다른 요소들을 더 고려해야 함
- 성능에 대한 직관을 실제 테스트로 확인하는 것이 중요
